<!DOCTYPE html>
<html lang="vi">

<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>Tetris Epic - X·∫øp g·∫°ch ƒë·ªânh cao</title>
    <style>
        :root {
            --bg: #0a0118;
            --panel: #130828;
            --accent: #ff2d75;
            --glow: #00ff88;
            --cell-size: 30px;
        }

        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            min-height: 100vh;
            display: flex;
            align-items: center;
            justify-content: center;
            background: radial-gradient(circle at 50% 50%, #1a0a3e, #0a0118);
            color: #fff;
            overflow: hidden;
        }

        body::before {
            content: '';
            position: fixed;
            top: -50%;
            left: -50%;
            width: 200%;
            height: 200%;
            background: radial-gradient(circle, rgba(255, 45, 117, 0.1) 0%, transparent 70%);
            animation: pulse 4s ease-in-out infinite;
            pointer-events: none;
        }

        @keyframes pulse {

            0%,
            100% {
                transform: scale(1);
                opacity: 0.3;
            }

            50% {
                transform: scale(1.1);
                opacity: 0.6;
            }
        }

        .wrap {
            display: flex;
            gap: 24px;
            align-items: flex-start;
            position: relative;
            z-index: 1;
        }

        .board {
            background: linear-gradient(145deg, #1a0a3e, #0d0520);
            padding: 24px;
            border-radius: 20px;
            box-shadow: 0 20px 60px rgba(255, 45, 117, 0.3), 0 0 40px rgba(0, 255, 136, 0.2);
            border: 2px solid rgba(255, 45, 117, 0.3);
            position: relative;
            transition: transform 0.1s;
        }

        .board.shake {
            animation: shake 0.3s cubic-bezier(.36, .07, .19, .97);
        }

        @keyframes shake {

            0%,
            100% {
                transform: translate(0, 0);
            }

            10%,
            30%,
            50%,
            70%,
            90% {
                transform: translate(-3px, 0);
            }

            20%,
            40%,
            60%,
            80% {
                transform: translate(3px, 0);
            }
        }

        .board::before {
            content: '';
            position: absolute;
            inset: -2px;
            background: linear-gradient(45deg, #ff2d75, #00ff88, #2d75ff);
            border-radius: 20px;
            opacity: 0;
            animation: borderGlow 3s linear infinite;
            z-index: -1;
        }

        @keyframes borderGlow {

            0%,
            100% {
                opacity: 0;
            }

            50% {
                opacity: 0.5;
            }
        }

        canvas {
            display: block;
            border-radius: 12px;
            box-shadow: inset 0 0 30px rgba(0, 0, 0, 0.8);
            image-rendering: crisp-edges;
        }

        .side {
            width: 280px;
            background: linear-gradient(145deg, #1a0a3e, #0d0520);
            padding: 20px;
            border-radius: 20px;
            display: flex;
            flex-direction: column;
            gap: 16px;
            border: 2px solid rgba(255, 45, 117, 0.2);
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
        }

        h1 {
            font-size: 28px;
            margin: 0;
            background: linear-gradient(135deg, #ff2d75, #00ff88);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            font-weight: 900;
            text-transform: uppercase;
            letter-spacing: 2px;
            text-shadow: 0 0 20px rgba(255, 45, 117, 0.5);
        }

        .score {
            display: flex;
            gap: 12px;
        }

        .card {
            background: linear-gradient(135deg, #1f0d3a, #0a0520);
            padding: 16px;
            border-radius: 12px;
            flex: 1;
            border: 1px solid rgba(255, 45, 117, 0.2);
            position: relative;
            overflow: hidden;
        }

        .card::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.1), transparent);
            animation: shine 3s infinite;
        }

        @keyframes shine {
            0% {
                left: -100%;
            }

            50%,
            100% {
                left: 100%;
            }
        }

        .card-label {
            font-size: 11px;
            color: rgba(255, 255, 255, 0.5);
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .card-value {
            font-weight: 900;
            font-size: 32px;
            margin-top: 4px;
            background: linear-gradient(135deg, #fff, #00ff88);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            text-shadow: 0 0 10px rgba(0, 255, 136, 0.5);
        }

        .preview {
            background: linear-gradient(135deg, #1f0d3a, #0a0520);
            border-radius: 12px;
            padding: 12px;
            display: grid;
            place-items: center;
            min-height: 80px;
            border: 1px solid rgba(255, 45, 117, 0.2);
        }

        .btn {
            background: linear-gradient(135deg, #ff2d75, #d11d5f);
            border: none;
            padding: 14px;
            border-radius: 12px;
            color: #fff;
            cursor: pointer;
            text-align: center;
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 1px;
            transition: all 0.3s;
            box-shadow: 0 4px 15px rgba(255, 45, 117, 0.4);
            position: relative;
            overflow: hidden;
        }

        .btn::before {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 0;
            height: 0;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.3);
            transform: translate(-50%, -50%);
            transition: width 0.6s, height 0.6s;
        }

        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(255, 45, 117, 0.6);
        }

        .btn:active::before {
            width: 300px;
            height: 300px;
        }

        .footer {
            font-size: 11px;
            color: rgba(255, 255, 255, 0.4);
            text-align: center;
        }

        .level-badge {
            font-size: 36px;
            font-weight: 900;
            background: linear-gradient(135deg, #00ff88, #2d75ff);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            text-shadow: 0 0 20px rgba(0, 255, 136, 0.5);
        }

        .spark {
            position: fixed;
            pointer-events: none;
            z-index: 9999;
            width: 4px;
            height: 12px;
            background: linear-gradient(180deg, #ffff00, #ff6600, transparent);
            box-shadow: 0 0 8px #ffff00;
        }

        @keyframes sparkFly {
            0% {
                transform: translate(0, 0) rotate(var(--rotate)) scale(1);
                opacity: 1;
            }

            100% {
                transform: translate(var(--tx), var(--ty)) rotate(calc(var(--rotate) + 180deg)) scale(0);
                opacity: 0;
            }
        }

        .explosion-particle {
            position: fixed;
            pointer-events: none;
            z-index: 9999;
            width: 8px;
            height: 8px;
            border-radius: 50%;
            box-shadow: 0 0 10px currentColor;
        }

        @keyframes explode {
            0% {
                transform: translate(0, 0) scale(1);
                opacity: 1;
            }

            100% {
                transform: translate(var(--tx), var(--ty)) scale(0);
                opacity: 0;
            }
        }

        .shockwave {
            position: fixed;
            pointer-events: none;
            z-index: 9998;
            border: 3px solid #ff6600;
            border-radius: 50%;
            box-shadow: 0 0 20px #ff6600, inset 0 0 20px #ff6600;
        }

        @keyframes shockwave {
            0% {
                width: 0;
                height: 0;
                opacity: 1;
            }

            100% {
                width: 300px;
                height: 300px;
                opacity: 0;
            }
        }

        @media (max-width: 800px) {
            .wrap {
                flex-direction: column;
                align-items: center;
            }

            .side {
                width: 94%;
            }
        }
    </style>
</head>

<body>
    <div class="wrap">
        <div class="board" id="board">
            <canvas id="game"></canvas>
        </div>

        <div class="side">
            <div style="display: flex; justify-content: space-between; align-items: center;">
                <h1>TETRIS</h1>
                <div class="level-badge" id="level">1</div>
            </div>

            <div class="score">
                <div class="card">
                    <div class="card-label">Score</div>
                    <div class="card-value" id="score">0</div>
                </div>
                <div class="card">
                    <div class="card-label">Lines</div>
                    <div class="card-value" id="lines">0</div>
                </div>
            </div>

            <div style="display: flex; gap: 12px;">
                <div style="flex: 1;">
                    <div class="card-label" style="margin-bottom: 8px;">NEXT</div>
                    <div class="preview" id="next"></div>
                </div>
                <div style="flex: 1;">
                    <div class="card-label" style="margin-bottom: 8px;">HOLD</div>
                    <div class="preview" id="hold"></div>
                </div>
            </div>

            <div style="display: flex; flex-direction: column; gap: 12px;">
                <button class="btn" id="btn-start">‚ñ∂ START</button>
                <div style="display: flex; gap: 12px;">
                    <button class="btn" id="btn-pause" style="flex: 1;">‚è∏ PAUSE</button>
                    <button class="btn" id="btn-reset" style="flex: 1;">‚Üª RESET</button>
                </div>
            </div>

            <div class="footer">
                ‚Üê ‚Üí Move | ‚Üë Rotate | ‚Üì Soft Drop | Space Hard Drop | C Hold
            </div>
        </div>
    </div>

    <script>
        (() => {
            const COLS = 10, ROWS = 20;
            const canvas = document.getElementById('game');
            const ctx = canvas.getContext('2d');
            const cell = 30;
            canvas.width = COLS * cell;
            canvas.height = ROWS * cell;
            const board = document.getElementById('board');

            // UI Elements
            const scoreEl = document.getElementById('score');
            const linesEl = document.getElementById('lines');
            const levelEl = document.getElementById('level');
            const nextEl = document.getElementById('next');
            const holdEl = document.getElementById('hold');

            // Enhanced Audio System with realistic sounds
            const audioCtx = new (window.AudioContext || window.webkitAudioContext)();

            function playTone(freq, duration, type = 'sine', volume = 0.1) {
                const osc = audioCtx.createOscillator();
                const gain = audioCtx.createGain();
                osc.connect(gain);
                gain.connect(audioCtx.destination);
                osc.type = type;
                osc.frequency.value = freq;
                gain.gain.setValueAtTime(volume, audioCtx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + duration);
                osc.start();
                osc.stop(audioCtx.currentTime + duration);
            }

            // Ti·∫øng g·∫°ch c·ªç s√°t - nh∆∞ ti·∫øng c∆∞a/c·∫Øt g·∫°ch
            function playGrindSound() {
                const duration = 0.15;
                // White noise cho hi·ªáu ·ª©ng c·ªç s√°t
                const bufferSize = audioCtx.sampleRate * duration;
                const buffer = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate);
                const data = buffer.getChannelData(0);

                for (let i = 0; i < bufferSize; i++) {
                    data[i] = (Math.random() * 2 - 1) * (1 - i / bufferSize);
                }

                const noise = audioCtx.createBufferSource();
                const filter = audioCtx.createBiquadFilter();
                const gain = audioCtx.createGain();

                noise.buffer = buffer;
                filter.type = 'bandpass';
                filter.frequency.value = 1200;
                filter.Q.value = 3;

                noise.connect(filter);
                filter.connect(gain);
                gain.connect(audioCtx.destination);

                gain.gain.setValueAtTime(0.2, audioCtx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + duration);

                noise.start();
                noise.stop(audioCtx.currentTime + duration);

                // Th√™m ti·∫øng va ch·∫°m kim lo·∫°i
                playTone(300, 0.08, 'square', 0.15);
                setTimeout(() => playTone(250, 0.05, 'square', 0.1), 40);
            }

            // Ti·∫øng bom n·ªï khi x√≥a h√†ng
            function playExplosionSound(intensity = 1) {
                const duration = 0.4 * intensity;

                // Bass thump
                const bass = audioCtx.createOscillator();
                const bassGain = audioCtx.createGain();
                bass.connect(bassGain);
                bassGain.connect(audioCtx.destination);
                bass.type = 'sine';
                bass.frequency.setValueAtTime(100, audioCtx.currentTime);
                bass.frequency.exponentialRampToValueAtTime(30, audioCtx.currentTime + duration);
                bassGain.gain.setValueAtTime(0.4 * intensity, audioCtx.currentTime);
                bassGain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + duration);
                bass.start();
                bass.stop(audioCtx.currentTime + duration);

                // Noise burst
                const bufferSize = audioCtx.sampleRate * duration;
                const buffer = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate);
                const data = buffer.getChannelData(0);

                for (let i = 0; i < bufferSize; i++) {
                    data[i] = (Math.random() * 2 - 1) * Math.pow(1 - i / bufferSize, 2);
                }

                const noise = audioCtx.createBufferSource();
                const noiseGain = audioCtx.createGain();
                noise.buffer = buffer;
                noise.connect(noiseGain);
                noiseGain.connect(audioCtx.destination);
                noiseGain.gain.setValueAtTime(0.3 * intensity, audioCtx.currentTime);
                noiseGain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + duration);
                noise.start();
                noise.stop(audioCtx.currentTime + duration);

                // Treble crack
                setTimeout(() => {
                    playTone(2000, 0.1, 'square', 0.2 * intensity);
                }, 20);
            }

            function playRotateSound() {
                playTone(600, 0.04, 'sine', 0.08);
            }

            function playMoveSound() {
                playTone(400, 0.03, 'sine', 0.06);
            }

            function playGameOverSound() {
                [400, 350, 300, 250, 200].forEach((f, i) => {
                    setTimeout(() => playTone(f, 0.2, 'sawtooth', 0.15), i * 150);
                });
            }

            // Tia l·ª≠a b·∫Øn ra t·ª´ v·ªã tr√≠ va ch·∫°m
            function createSparks(x, y, count = 25) {
                const rect = canvas.getBoundingClientRect();
                const centerX = rect.left + x;
                const centerY = rect.top + y;

                for (let i = 0; i < count; i++) {
                    const spark = document.createElement('div');
                    spark.className = 'spark';

                    const angle = (Math.random() * 120 - 60) + 90; // B·∫Øn l√™n tr√™n ch·ªß y·∫øu
                    const velocity = 50 + Math.random() * 100;
                    const tx = Math.cos(angle * Math.PI / 180) * velocity;
                    const ty = Math.sin(angle * Math.PI / 180) * velocity + Math.random() * 50; // Gravity
                    const rotate = Math.random() * 360;

                    spark.style.cssText = `
                        left: ${centerX}px;
                        top: ${centerY}px;
                        --tx: ${tx}px;
                        --ty: ${ty}px;
                        --rotate: ${rotate}deg;
                        animation: sparkFly ${0.3 + Math.random() * 0.3}s ease-out forwards;
                    `;

                    document.body.appendChild(spark);
                    setTimeout(() => spark.remove(), 600);
                }
            }

            // Rung m√†n h√¨nh khi va ch·∫°m
            function screenShake(intensity = 1) {
                board.classList.remove('shake');
                void board.offsetWidth; // Force reflow
                board.classList.add('shake');
                setTimeout(() => board.classList.remove('shake'), 300);

                // Vibration API n·∫øu c√≥
                if (navigator.vibrate) {
                    navigator.vibrate(intensity * 50);
                }
            }

            // V·ª• n·ªï v·ªõi shockwave khi x√≥a h√†ng
            function createExplosion(x, y, color, intensity = 1) {
                const rect = canvas.getBoundingClientRect();
                const centerX = rect.left + x;
                const centerY = rect.top + y;

                // Shockwave
                const shockwave = document.createElement('div');
                shockwave.className = 'shockwave';
                shockwave.style.cssText = `
                    left: ${centerX}px;
                    top: ${centerY}px;
                    transform: translate(-50%, -50%);
                    animation: shockwave ${0.6 * intensity}s ease-out forwards;
                `;
                document.body.appendChild(shockwave);
                setTimeout(() => shockwave.remove(), 600 * intensity);

                // Particles
                const particleCount = 40 * intensity;
                const colors = ['#ff6600', '#ffff00', '#ff0000', '#ff9900'];

                for (let i = 0; i < particleCount; i++) {
                    const particle = document.createElement('div');
                    particle.className = 'explosion-particle';

                    const angle = (Math.random() * 360);
                    const velocity = 80 + Math.random() * 120;
                    const tx = Math.cos(angle * Math.PI / 180) * velocity;
                    const ty = Math.sin(angle * Math.PI / 180) * velocity;
                    const particleColor = colors[Math.floor(Math.random() * colors.length)];

                    particle.style.cssText = `
                        left: ${centerX}px;
                        top: ${centerY}px;
                        background: ${particleColor};
                        color: ${particleColor};
                        --tx: ${tx}px;
                        --ty: ${ty}px;
                        animation: explode ${0.5 + Math.random() * 0.5}s ease-out forwards;
                    `;

                    document.body.appendChild(particle);
                    setTimeout(() => particle.remove(), 1000);
                }
            }

            // Tetromino Shapes
            const SHAPES = {
                I: { color: '#00f0f0', blocks: [[0, 0, 0, 0], [1, 1, 1, 1], [0, 0, 0, 0], [0, 0, 0, 0]] },
                J: { color: '#0000f0', blocks: [[1, 0, 0], [1, 1, 1], [0, 0, 0]] },
                L: { color: '#f0a000', blocks: [[0, 0, 1], [1, 1, 1], [0, 0, 0]] },
                O: { color: '#f0f000', blocks: [[1, 1], [1, 1]] },
                S: { color: '#00f000', blocks: [[0, 1, 1], [1, 1, 0], [0, 0, 0]] },
                T: { color: '#a000f0', blocks: [[0, 1, 0], [1, 1, 1], [0, 0, 0]] },
                Z: { color: '#f00000', blocks: [[1, 1, 0], [0, 1, 1], [0, 0, 0]] }
            };

            // Game State
            let grid, current, nextQueue, holdPiece = null, holdUsed = false;
            let score = 0, lines = 0, level = 1;
            let dropCounter = 0, dropInterval = 800, lastTime = 0;
            let running = false, paused = false, gameOver = false;

            function createGrid() {
                return Array.from({ length: ROWS }, () => Array(COLS).fill(0));
            }

            function drawCell(x, y, color, glow = false) {
                const px = x * cell;
                const py = y * cell;

                const gradient = ctx.createLinearGradient(px, py, px + cell, py + cell);
                gradient.addColorStop(0, color);
                gradient.addColorStop(1, adjustBrightness(color, -30));
                ctx.fillStyle = gradient;
                ctx.fillRect(px + 1, py + 1, cell - 2, cell - 2);

                if (glow) {
                    ctx.shadowColor = color;
                    ctx.shadowBlur = 15;
                    ctx.strokeStyle = adjustBrightness(color, 50);
                    ctx.lineWidth = 2;
                    ctx.strokeRect(px + 2, py + 2, cell - 4, cell - 4);
                    ctx.shadowBlur = 0;
                }

                ctx.fillStyle = 'rgba(255,255,255,0.3)';
                ctx.fillRect(px + 2, py + 2, cell - 8, 3);
            }

            function adjustBrightness(color, amount) {
                const num = parseInt(color.replace('#', ''), 16);
                const r = Math.max(0, Math.min(255, (num >> 16) + amount));
                const g = Math.max(0, Math.min(255, ((num >> 8) & 0x00FF) + amount));
                const b = Math.max(0, Math.min(255, (num & 0x0000FF) + amount));
                return `#${((r << 16) | (g << 8) | b).toString(16).padStart(6, '0')}`;
            }

            function drawGrid() {
                ctx.fillStyle = '#050212';
                ctx.fillRect(0, 0, canvas.width, canvas.height);

                ctx.strokeStyle = 'rgba(255,45,117,0.1)';
                ctx.lineWidth = 1;
                for (let i = 0; i <= COLS; i++) {
                    ctx.beginPath();
                    ctx.moveTo(i * cell, 0);
                    ctx.lineTo(i * cell, canvas.height);
                    ctx.stroke();
                }
                for (let i = 0; i <= ROWS; i++) {
                    ctx.beginPath();
                    ctx.moveTo(0, i * cell);
                    ctx.lineTo(canvas.width, i * cell);
                    ctx.stroke();
                }

                for (let r = 0; r < ROWS; r++) {
                    for (let c = 0; c < COLS; c++) {
                        if (grid[r][c]) {
                            drawCell(c, r, grid[r][c], true);
                        }
                    }
                }
            }

            function randomPiece() {
                const keys = Object.keys(SHAPES);
                const k = keys[Math.floor(Math.random() * keys.length)];
                const def = SHAPES[k];
                return {
                    type: k,
                    matrix: def.blocks.map(row => row.slice()),
                    color: def.color,
                    x: Math.floor((COLS - def.blocks[0].length) / 2),
                    y: -1
                };
            }

            function rotate(matrix) {
                const N = matrix.length;
                const res = Array.from({ length: N }, () => Array(N).fill(0));
                for (let y = 0; y < N; y++) {
                    for (let x = 0; x < N; x++) {
                        res[x][N - 1 - y] = matrix[y][x];
                    }
                }
                return res;
            }

            function collide(piece, pos) {
                for (let y = 0; y < piece.matrix.length; y++) {
                    for (let x = 0; x < piece.matrix[y].length; x++) {
                        if (piece.matrix[y][x]) {
                            const gx = pos.x + x;
                            const gy = pos.y + y;
                            if (gx < 0 || gx >= COLS || gy >= ROWS) return true;
                            if (gy >= 0 && grid[gy][gx]) return true;
                        }
                    }
                }
                return false;
            }

            function merge(piece) {
                let minY = ROWS;
                const impactPoints = [];

                for (let y = 0; y < piece.matrix.length; y++) {
                    for (let x = 0; x < piece.matrix[y].length; x++) {
                        if (piece.matrix[y][x]) {
                            const gx = piece.x + x;
                            const gy = piece.y + y;
                            if (gy >= 0) {
                                grid[gy][gx] = piece.color;
                                if (gy < minY) minY = gy;

                                // Ki·ªÉm tra va ch·∫°m v·ªõi ƒë√°y ho·∫∑c g·∫°ch kh√°c
                                if (gy === ROWS - 1 || (gy + 1 < ROWS && grid[gy + 1][gx])) {
                                    impactPoints.push({ x: gx, y: gy });
                                }
                            }
                        }
                    }
                }

                // T·∫°o hi·ªáu ·ª©ng tia l·ª≠a t·∫°i c√°c ƒëi·ªÉm va ch·∫°m
                impactPoints.forEach(point => {
                    const px = (point.x + 0.5) * cell;
                    const py = (point.y + 1) * cell;
                    createSparks(px, py, 15);
                });

                if (impactPoints.length > 0) {
                    playGrindSound();
                    screenShake(0.5);
                }
            }

            function sweep() {
                let rowCount = 0;
                const clearedRows = [];

                for (let y = ROWS - 1; y >= 0; y--) {
                    let full = true;
                    for (let x = 0; x < COLS; x++) {
                        if (!grid[y][x]) {
                            full = false;
                            break;
                        }
                    }
                    if (full) {
                        clearedRows.push(y);
                        grid.splice(y, 1);
                        grid.unshift(Array(COLS).fill(0));
                        rowCount++;
                        y++;
                    }
                }

                if (rowCount > 0) {
                    // V·ª• n·ªï BOM t·∫°i c√°c h√†ng b·ªã x√≥a
                    clearedRows.forEach((row, index) => {
                        setTimeout(() => {
                            for (let x = 0; x < COLS; x += 2) {
                                const px = (x + 0.5) * cell;
                                const py = row * cell;
                                createExplosion(px, py, '#ff6600', rowCount * 0.5);
                            }
                        }, index * 50);
                    });

                    // Rung m·∫°nh khi x√≥a h√†ng
                    screenShake(rowCount);

                    // √Çm thanh bom n·ªï
                    playExplosionSound(rowCount);

                    // Scoring
                    const pointsMap = { 1: 40, 2: 100, 3: 300, 4: 1200 };
                    score += (pointsMap[rowCount] || rowCount * 100) * level;
                    lines += rowCount;

                    const newLevel = Math.floor(lines / 10) + 1;
                    if (newLevel !== level) {
                        level = newLevel;
                        dropInterval = Math.max(100, 800 - (level - 1) * 50);
                        playTone(1200, 0.3, 'square', 0.2);
                    }

                    updateUI();
                }
            }

            function spawn() {
                current = nextQueue.shift();
                nextQueue.push(randomPiece());
                holdUsed = false;

                if (collide(current, { x: current.x, y: current.y })) {
                    running = false;
                    gameOver = true;
                    playGameOverSound();
                    setTimeout(() => {
                        alert(`üéÆ GAME OVER!\n\nüíØ Score: ${score}\nüìä Lines: ${lines}\n‚≠ê Level: ${level}`);
                    }, 800);
                }
                renderHoldNext();
            }

            function hardDrop() {
                let dropDist = 0;
                while (!collide(current, { x: current.x, y: current.y + 1 })) {
                    current.y++;
                    dropDist++;
                }
                score += dropDist * 2;

                // T·∫°o hi·ªáu ·ª©ng r∆°i m·∫°nh
                merge(current);
                sweep();
                spawn();
                updateUI();
            }

            function softDrop() {
                current.y++;
                if (collide(current, { x: current.x, y: current.y })) {
                    current.y--;
                    merge(current);
                    sweep();
                    spawn();
                } else {
                    score += 1;
                    updateUI();
                }
            }

            function move(dir) {
                current.x += dir;
                if (collide(current, { x: current.x, y: current.y })) {
                    current.x -= dir;
                } else {
                    playMoveSound();
                }
            }

            function rotateCurrent() {
                const prev = current.matrix;
                current.matrix = rotate(prev);
                const oldX = current.x;

                const kicks = [0, -1, 1, -2, 2];
                let ok = false;
                for (let k of kicks) {
                    current.x = oldX + k;
                    if (!collide(current, { x: current.x, y: current.y })) {
                        ok = true;
                        break;
                    }
                }

                if (!ok) {
                    current.matrix = prev;
                    current.x = oldX;
                } else {
                    playRotateSound();
                }
            }

            function hold() {
                if (holdUsed) return;
                if (!holdPiece) {
                    holdPiece = { type: current.type, matrix: current.matrix, color: current.color };
                    spawn();
                } else {
                    const tmp = { ...current };
                    current = { ...holdPiece, x: Math.floor((COLS - holdPiece.matrix[0].length) / 2), y: -1 };
                    holdPiece = tmp;
                }
                holdUsed = true;
                renderHoldNext();
                playTone(600, 0.05, 'sine', 0.08);
            }

            function drawCurrent() {
                // Draw ghost piece
                const ghost = { ...current };
                while (!collide(ghost, { x: ghost.x, y: ghost.y + 1 })) {
                    ghost.y++;
                }
                for (let y = 0; y < ghost.matrix.length; y++) {
                    for (let x = 0; x < ghost.matrix[y].length; x++) {
                        if (ghost.matrix[y][x]) {
                            const gx = ghost.x + x;
                            const gy = ghost.y + y;
                            if (gy >= 0) {
                                ctx.fillStyle = 'rgba(255,255,255,0.1)';
                                ctx.fillRect(gx * cell + 2, gy * cell + 2, cell - 4, cell - 4);
                            }
                        }
                    }
                }

                // Draw current piece with glow
                for (let y = 0; y < current.matrix.length; y++) {
                    for (let x = 0; x < current.matrix[y].length; x++) {
                        if (current.matrix[y][x]) {
                            const gx = current.x + x;
                            const gy = current.y + y;
                            if (gy >= 0) {
                                drawCell(gx, gy, current.color, true);
                            }
                        }
                    }
                }
            }

            function renderHoldNext() {
                nextEl.innerHTML = '';
                holdEl.innerHTML = '';
                if (nextQueue[0]) drawMini(nextQueue[0], nextEl);
                if (holdPiece) drawMini(holdPiece, holdEl);
            }

            function drawMini(piece, container) {
                const miniCanvas = document.createElement('canvas');
                const mat = piece.matrix;
                const s = 20;
                miniCanvas.width = mat[0].length * s;
                miniCanvas.height = mat.length * s;
                const mctx = miniCanvas.getContext('2d');

                for (let y = 0; y < mat.length; y++) {
                    for (let x = 0; x < mat[y].length; x++) {
                        if (mat[y][x]) {
                            mctx.fillStyle = piece.color;
                            mctx.fillRect(x * s + 2, y * s + 2, s - 4, s - 4);
                            mctx.strokeStyle = adjustBrightness(piece.color, 50);
                            mctx.lineWidth = 2;
                            mctx.strokeRect(x * s + 2, y * s + 2, s - 4, s - 4);
                        }
                    }
                }
                container.appendChild(miniCanvas);
            }

            function updateUI() {
                scoreEl.textContent = score.toLocaleString();
                linesEl.textContent = lines;
                levelEl.textContent = level;
            }

            function update(time = 0) {
                if (!running || paused) {
                    lastTime = time;
                    requestAnimationFrame(update);
                    return;
                }

                const delta = time - lastTime;
                lastTime = time;
                dropCounter += delta;

                if (dropCounter > dropInterval) {
                    if (!collide(current, { x: current.x, y: current.y + 1 })) {
                        current.y++;
                    } else {
                        merge(current);
                        sweep();
                        spawn();
                    }
                    dropCounter = 0;
                }

                drawGrid();
                drawCurrent();
                requestAnimationFrame(update);
            }

            // Input handling
            document.addEventListener('keydown', (e) => {
                if (!running || paused) return;

                switch (e.keyCode) {
                    case 37: move(-1); break;
                    case 39: move(1); break;
                    case 38: rotateCurrent(); break;
                    case 40: softDrop(); break;
                    case 32: e.preventDefault(); hardDrop(); break;
                    case 67: hold(); break;
                    case 80: togglePause(); break;
                }
            });

            // Buttons
            document.getElementById('btn-start').addEventListener('click', start);
            document.getElementById('btn-pause').addEventListener('click', togglePause);
            document.getElementById('btn-reset').addEventListener('click', () => {
                if (confirm('üîÑ Reset game?')) init();
            });

            function togglePause() {
                if (!running) return;
                paused = !paused;
                document.getElementById('btn-pause').textContent = paused ? '‚ñ∂ RESUME' : '‚è∏ PAUSE';
                if (!paused) lastTime = performance.now();
            }

            function init() {
                grid = createGrid();
                nextQueue = [randomPiece(), randomPiece(), randomPiece()];
                current = randomPiece();
                holdPiece = null;
                holdUsed = false;
                score = 0;
                lines = 0;
                level = 1;
                dropInterval = 800;
                running = false;
                paused = false;
                gameOver = false;
                updateUI();
                renderHoldNext();
                drawGrid();
            }

            function start() {
                if (gameOver) init();
                if (!running) {
                    running = true;
                    lastTime = performance.now();
                    dropCounter = 0;
                    spawn();
                    requestAnimationFrame(update);
                    playTone(1000, 0.1, 'square', 0.15);
                }
            }

            // Initialize
            init();
            document.body.addEventListener('touchstart', () => audioCtx.resume(), { once: true });
        })();
    </script>
</body>

</html>
<!DOCTYPE html>
<html lang="vi">

<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>Tetris Epic - X·∫øp g·∫°ch ƒë·ªânh cao</title>
    <style>
        :root {
            --bg: #0a0118;
            --panel: #130828;
            --accent: #ff2d75;
            --glow: #00ff88;
            --cell-size: 30px;
            --text-primary: #ffffff;
            --text-secondary: rgba(255, 255, 255, 0.7);
            --text-tertiary: rgba(255, 255, 255, 0.5);
        }

        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            min-height: 100vh;
            display: flex;
            align-items: center;
            justify-content: center;
            background: radial-gradient(circle at 50% 50%, #1a0a3e, #0a0118);
            color: var(--text-primary);
            overflow: hidden;
            position: relative;
        }

        body::before {
            content: '';
            position: fixed;
            top: -50%;
            left: -50%;
            width: 200%;
            height: 200%;
            background: radial-gradient(circle, rgba(255, 45, 117, 0.1) 0%, transparent 70%);
            animation: pulse 4s ease-in-out infinite;
            pointer-events: none;
        }

        @keyframes pulse {

            0%,
            100% {
                transform: scale(1);
                opacity: 0.3;
            }

            50% {
                transform: scale(1.1);
                opacity: 0.6;
            }
        }

        .container {
            width: 100%;
            max-width: 1200px;
            padding: 20px;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 20px;
            position: relative;
            z-index: 1;
        }

        .header {
            text-align: center;
            margin-bottom: 10px;
            width: 100%;
        }

        .header h1 {
            font-size: clamp(2rem, 5vw, 3.5rem);
            margin: 0;
            background: linear-gradient(135deg, #ff2d75, #00ff88);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            font-weight: 900;
            text-transform: uppercase;
            letter-spacing: 3px;
            text-shadow: 0 0 20px rgba(255, 45, 117, 0.5);
            position: relative;
            display: inline-block;
        }

        .header h1::after {
            content: '';
            position: absolute;
            bottom: -10px;
            left: 50%;
            transform: translateX(-50%);
            width: 100px;
            height: 3px;
            background: linear-gradient(90deg, transparent, #ff2d75, #00ff88, transparent);
            border-radius: 3px;
        }

        .game-area {
            display: flex;
            flex-direction: row;
            gap: 20px;
            width: 100%;
            max-width: 900px;
            justify-content: center;
            align-items: flex-start;
        }

        .board-container {
            position: relative;
            flex-shrink: 0;
        }

        .board {
            background: linear-gradient(145deg, #1a0a3e, #0d0520);
            padding: 20px;
            border-radius: 20px;
            box-shadow: 0 20px 60px rgba(255, 45, 117, 0.3), 0 0 40px rgba(0, 255, 136, 0.2);
            border: 2px solid rgba(255, 45, 117, 0.3);
            position: relative;
            transition: transform 0.1s;
        }

        .board.shake {
            animation: shake 0.3s cubic-bezier(.36, .07, .19, .97);
        }

        @keyframes shake {

            0%,
            100% {
                transform: translate(0, 0);
            }

            10%,
            30%,
            50%,
            70%,
            90% {
                transform: translate(-3px, 0);
            }

            20%,
            40%,
            60%,
            80% {
                transform: translate(3px, 0);
            }
        }

        .board::before {
            content: '';
            position: absolute;
            inset: -2px;
            background: linear-gradient(45deg, #ff2d75, #00ff88, #2d75ff);
            border-radius: 20px;
            opacity: 0;
            animation: borderGlow 3s linear infinite;
            z-index: -1;
        }

        @keyframes borderGlow {

            0%,
            100% {
                opacity: 0;
            }

            50% {
                opacity: 0.5;
            }
        }

        canvas {
            display: block;
            border-radius: 12px;
            box-shadow: inset 0 0 30px rgba(0, 0, 0, 0.8);
            image-rendering: crisp-edges;
        }

        .info-panel {
            display: flex;
            flex-direction: column;
            gap: 20px;
            width: 100%;
            max-width: 300px;
        }

        .stats {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px;
        }

        .stat-card {
            background: linear-gradient(135deg, #1f0d3a, #0a0520);
            padding: 18px;
            border-radius: 16px;
            border: 1px solid rgba(255, 45, 117, 0.2);
            position: relative;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            text-align: center;
            box-shadow: 0 8px 20px rgba(0, 0, 0, 0.3);
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .stat-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 12px 25px rgba(0, 0, 0, 0.4);
        }

        .stat-card::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.1), transparent);
            animation: shine 3s infinite;
        }

        @keyframes shine {
            0% {
                left: -100%;
            }

            50%,
            100% {
                left: 100%;
            }
        }

        .stat-label {
            font-size: 12px;
            color: var(--text-secondary);
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-bottom: 8px;
        }

        .stat-value {
            font-weight: 900;
            font-size: 32px;
            background: linear-gradient(135deg, #fff, #00ff88);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            text-shadow: 0 0 10px rgba(0, 255, 136, 0.5);
        }

        .level-badge {
            font-size: 36px;
            font-weight: 900;
            background: linear-gradient(135deg, #00ff88, #2d75ff);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            text-shadow: 0 0 20px rgba(0, 255, 136, 0.5);
        }

        .preview-container {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px;
        }

        .preview-box {
            background: linear-gradient(135deg, #1f0d3a, #0a0520);
            border-radius: 16px;
            padding: 15px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 120px;
            border: 1px solid rgba(255, 45, 117, 0.2);
            box-shadow: 0 8px 20px rgba(0, 0, 0, 0.3);
        }

        .preview-label {
            font-size: 12px;
            color: var(--text-secondary);
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-bottom: 10px;
        }

        .preview-content {
            display: flex;
            align-items: center;
            justify-content: center;
            width: 100%;
            height: 100%;
        }

        .controls {
            display: flex;
            flex-direction: column;
            gap: 12px;
        }

        .btn {
            background: linear-gradient(135deg, #ff2d75, #d11d5f);
            border: none;
            padding: 16px;
            border-radius: 12px;
            color: #fff;
            cursor: pointer;
            text-align: center;
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 1px;
            transition: all 0.3s;
            box-shadow: 0 4px 15px rgba(255, 45, 117, 0.4);
            position: relative;
            overflow: hidden;
            font-size: 14px;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
        }

        .btn::before {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 0;
            height: 0;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.3);
            transform: translate(-50%, -50%);
            transition: width 0.6s, height 0.6s;
        }

        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(255, 45, 117, 0.6);
        }

        .btn:active::before {
            width: 300px;
            height: 300px;
        }

        .btn-secondary {
            background: linear-gradient(135deg, #2d75ff, #1a5fd9);
            box-shadow: 0 4px 15px rgba(45, 117, 255, 0.4);
        }

        .btn-secondary:hover {
            box-shadow: 0 6px 20px rgba(45, 117, 255, 0.6);
        }

        .btn-group {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 12px;
        }

        .footer {
            font-size: 12px;
            color: var(--text-tertiary);
            text-align: center;
            margin-top: 10px;
            max-width: 600px;
            line-height: 1.5;
        }

        .mobile-controls {
            display: none;
            grid-template-columns: repeat(3, 1fr);
            grid-template-rows: repeat(3, 1fr);
            gap: 10px;
            width: 100%;
            max-width: 300px;
            margin-top: 20px;
        }

        .mobile-btn {
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 12px;
            color: white;
            font-size: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
            height: 60px;
            cursor: pointer;
            transition: all 0.2s;
            backdrop-filter: blur(10px);
        }

        .mobile-btn:active {
            background: rgba(255, 255, 255, 0.2);
            transform: scale(0.95);
        }

        .mobile-btn-rotate {
            grid-column: 2;
            grid-row: 1;
        }

        .mobile-btn-left {
            grid-column: 1;
            grid-row: 2;
        }

        .mobile-btn-down {
            grid-column: 2;
            grid-row: 2;
        }

        .mobile-btn-right {
            grid-column: 3;
            grid-row: 2;
        }

        .mobile-btn-drop {
            grid-column: 2;
            grid-row: 3;
        }

        .mobile-btn-hold {
            grid-column: 3;
            grid-row: 1;
        }

        .spark {
            position: fixed;
            pointer-events: none;
            z-index: 9999;
            width: 4px;
            height: 12px;
            background: linear-gradient(180deg, #ffff00, #ff6600, transparent);
            box-shadow: 0 0 8px #ffff00;
        }

        @keyframes sparkFly {
            0% {
                transform: translate(0, 0) rotate(var(--rotate)) scale(1);
                opacity: 1;
            }

            100% {
                transform: translate(var(--tx), var(--ty)) rotate(calc(var(--rotate) + 180deg)) scale(0);
                opacity: 0;
            }
        }

        .explosion-particle {
            position: fixed;
            pointer-events: none;
            z-index: 9999;
            width: 8px;
            height: 8px;
            border-radius: 50%;
            box-shadow: 0 0 10px currentColor;
        }

        @keyframes explode {
            0% {
                transform: translate(0, 0) scale(1);
                opacity: 1;
            }

            100% {
                transform: translate(var(--tx), var(--ty)) scale(0);
                opacity: 0;
            }
        }

        .shockwave {
            position: fixed;
            pointer-events: none;
            z-index: 9998;
            border: 3px solid #ff6600;
            border-radius: 50%;
            box-shadow: 0 0 20px #ff6600, inset 0 0 20px #ff6600;
        }

        @keyframes shockwave {
            0% {
                width: 0;
                height: 0;
                opacity: 1;
            }

            100% {
                width: 300px;
                height: 300px;
                opacity: 0;
            }
        }

        /* Responsive Design */
        @media (max-width: 900px) {
            .game-area {
                flex-direction: column;
                align-items: center;
            }

            .info-panel {
                max-width: 100%;
                width: 100%;
            }

            .stats,
            .preview-container {
                grid-template-columns: repeat(4, 1fr);
            }

            .controls {
                flex-direction: row;
                flex-wrap: wrap;
            }

            .btn {
                flex: 1;
                min-width: 120px;
            }

            .btn-group {
                width: 100%;
            }
        }

        @media (max-width: 768px) {
            .container {
                padding: 10px;
            }

            .board {
                padding: 15px;
            }

            .stats,
            .preview-container {
                grid-template-columns: repeat(2, 1fr);
            }

            .mobile-controls {
                display: grid;
            }

            .footer {
                font-size: 11px;
            }
        }

        @media (max-width: 480px) {

            .stats,
            .preview-container {
                grid-template-columns: 1fr;
            }

            .btn {
                font-size: 12px;
                padding: 14px;
            }

            .mobile-btn {
                height: 50px;
                font-size: 18px;
            }
        }

        /* Game state indicators */
        .game-state {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.8);
            padding: 20px 40px;
            border-radius: 16px;
            text-align: center;
            z-index: 10;
            backdrop-filter: blur(10px);
            border: 2px solid rgba(255, 45, 117, 0.5);
            box-shadow: 0 0 30px rgba(255, 45, 117, 0.5);
            display: none;
        }

        .game-state h2 {
            color: #ff2d75;
            margin-bottom: 10px;
            font-size: 28px;
        }

        .game-state p {
            color: white;
            margin-bottom: 15px;
        }

        .game-over .game-state {
            display: block;
        }

        .paused .game-state {
            display: block;
        }
    </style>
</head>

<body>
    <div class="container">
        <div class="header">
            <h1>TETRIS EPIC</h1>
        </div>

        <div class="game-area">
            <div class="board-container">
                <div class="board" id="board">
                    <canvas id="game"></canvas>
                    <div class="game-state" id="pause-state">
                        <h2>PAUSED</h2>
                        <p>Click Resume to continue</p>
                    </div>
                    <div class="game-state" id="game-over-state">
                        <h2>GAME OVER</h2>
                        <p id="final-score">Score: 0</p>
                        <button class="btn" id="btn-restart">Play Again</button>
                    </div>
                </div>
            </div>

            <div class="info-panel">
                <div class="stats">
                    <div class="stat-card">
                        <div class="stat-label">Score</div>
                        <div class="stat-value" id="score">0</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-label">Lines</div>
                        <div class="stat-value" id="lines">0</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-label">Level</div>
                        <div class="stat-value" id="level">1</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-label">Speed</div>
                        <div class="stat-value" id="speed">1x</div>
                    </div>
                </div>

                <div class="preview-container">
                    <div class="preview-box">
                        <div class="preview-label">Next</div>
                        <div class="preview-content" id="next"></div>
                    </div>
                    <div class="preview-box">
                        <div class="preview-label">Hold</div>
                        <div class="preview-content" id="hold"></div>
                    </div>
                </div>

                <div class="controls">
                    <button class="btn" id="btn-start">
                        <span>‚ñ∂</span> START GAME
                    </button>
                    <div class="btn-group">
                        <button class="btn" id="btn-pause">
                            <span>‚è∏</span> PAUSE
                        </button>
                        <button class="btn btn-secondary" id="btn-reset">
                            <span>‚Üª</span> RESET
                        </button>
                    </div>
                </div>
            </div>
        </div>

        <div class="mobile-controls">
            <div class="mobile-btn mobile-btn-rotate">‚Üª</div>
            <div class="mobile-btn mobile-btn-hold">H</div>
            <div class="mobile-btn mobile-btn-left">‚Üê</div>
            <div class="mobile-btn mobile-btn-down">‚Üì</div>
            <div class="mobile-btn mobile-btn-right">‚Üí</div>
            <div class="mobile-btn mobile-btn-drop">‚Üì</div>
        </div>

        <div class="footer">
            <p>‚Üê ‚Üí Move | ‚Üë Rotate | ‚Üì Soft Drop | Space Hard Drop | C Hold | P Pause</p>
            <p>Tap buttons on mobile or use keyboard controls on desktop</p>
        </div>
    </div>

    <script>
        (() => {
            const COLS = 10, ROWS = 20;
            const canvas = document.getElementById('game');
            const ctx = canvas.getContext('2d');
            const cell = 30;
            canvas.width = COLS * cell;
            canvas.height = ROWS * cell;
            const board = document.getElementById('board');

            // UI Elements
            const scoreEl = document.getElementById('score');
            const linesEl = document.getElementById('lines');
            const levelEl = document.getElementById('level');
            const nextEl = document.getElementById('next');
            const holdEl = document.getElementById('hold');

            // Enhanced Audio System - √¢m thanh ch·∫•t l∆∞·ª£ng cao
            const audioCtx = new (window.AudioContext || window.webkitAudioContext)();

            // Master volume control
            const masterGain = audioCtx.createGain();
            masterGain.gain.value = 0.3;
            masterGain.connect(audioCtx.destination);

            function playTone(freq, duration, type = 'sine', volume = 0.1, destination = masterGain) {
                const osc = audioCtx.createOscillator();
                const gain = audioCtx.createGain();
                osc.connect(gain);
                gain.connect(destination);
                osc.type = type;
                osc.frequency.value = freq;
                gain.gain.setValueAtTime(volume, audioCtx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + duration);
                osc.start();
                osc.stop(audioCtx.currentTime + duration);
            }

            // Ti·∫øng g·∫°ch va ch·∫°m - s·∫Øc n√©t, c√≥ ƒë·ªô s√¢u
            function playGrindSound() {
                const now = audioCtx.currentTime;
                const duration = 0.12;

                // T·∫°o white noise ch·∫•t l∆∞·ª£ng cao
                const bufferSize = audioCtx.sampleRate * duration;
                const buffer = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate);
                const data = buffer.getChannelData(0);

                for (let i = 0; i < bufferSize; i++) {
                    const decay = Math.pow(1 - i / bufferSize, 1.5);
                    data[i] = (Math.random() * 2 - 1) * decay;
                }

                const noise = audioCtx.createBufferSource();
                const filter = audioCtx.createBiquadFilter();
                const gain = audioCtx.createGain();

                noise.buffer = buffer;
                filter.type = 'bandpass';
                filter.frequency.value = 1800;
                filter.Q.value = 4;

                noise.connect(filter);
                filter.connect(gain);
                gain.connect(masterGain);

                gain.gain.setValueAtTime(0.25, now);
                gain.gain.exponentialRampToValueAtTime(0.001, now + duration);

                noise.start(now);
                noise.stop(now + duration);

                // Ti·∫øng "thud" bass khi ch·∫°m ƒë·∫•t
                const bass = audioCtx.createOscillator();
                const bassGain = audioCtx.createGain();
                bass.connect(bassGain);
                bassGain.connect(masterGain);
                bass.type = 'sine';
                bass.frequency.setValueAtTime(150, now);
                bass.frequency.exponentialRampToValueAtTime(50, now + 0.1);
                bassGain.gain.setValueAtTime(0.3, now);
                bassGain.gain.exponentialRampToValueAtTime(0.001, now + 0.1);
                bass.start(now);
                bass.stop(now + 0.1);

                // Ti·∫øng "click" s·∫Øc
                setTimeout(() => {
                    const click = audioCtx.createOscillator();
                    const clickGain = audioCtx.createGain();
                    click.connect(clickGain);
                    clickGain.connect(masterGain);
                    click.type = 'square';
                    click.frequency.value = 800;
                    clickGain.gain.setValueAtTime(0.15, audioCtx.currentTime);
                    clickGain.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 0.03);
                    click.start();
                    click.stop(audioCtx.currentTime + 0.03);
                }, 10);
            }

            // Ti·∫øng bom n·ªï EPIC - c√≥ l·ªõp, c√≥ chi·ªÅu s√¢u
            function playExplosionSound(intensity = 1) {
                const now = audioCtx.currentTime;
                const duration = 0.5 + (intensity * 0.15);

                // Layer 1: Sub bass - t·∫°o c·∫£m gi√°c rung
                const subBass = audioCtx.createOscillator();
                const subGain = audioCtx.createGain();
                subBass.connect(subGain);
                subGain.connect(masterGain);
                subBass.type = 'sine';
                subBass.frequency.setValueAtTime(60, now);
                subBass.frequency.exponentialRampToValueAtTime(20, now + duration);
                subGain.gain.setValueAtTime(0.5 * intensity, now);
                subGain.gain.exponentialRampToValueAtTime(0.001, now + duration);
                subBass.start(now);
                subBass.stop(now + duration);

                // Layer 2: Mid bass punch
                const midBass = audioCtx.createOscillator();
                const midGain = audioCtx.createGain();
                midBass.connect(midGain);
                midGain.connect(masterGain);
                midBass.type = 'triangle';
                midBass.frequency.setValueAtTime(120, now);
                midBass.frequency.exponentialRampToValueAtTime(40, now + duration * 0.6);
                midGain.gain.setValueAtTime(0.4 * intensity, now);
                midGain.gain.exponentialRampToValueAtTime(0.001, now + duration * 0.6);
                midBass.start(now);
                midBass.stop(now + duration * 0.6);

                // Layer 3: Noise burst - ti·∫øng "boom"
                const bufferSize = audioCtx.sampleRate * duration;
                const buffer = audioCtx.createBuffer(2, bufferSize, audioCtx.sampleRate);

                for (let channel = 0; channel < 2; channel++) {
                    const data = buffer.getChannelData(channel);
                    for (let i = 0; i < bufferSize; i++) {
                        const decay = Math.pow(1 - i / bufferSize, 2.5);
                        data[i] = (Math.random() * 2 - 1) * decay;
                    }
                }

                const noise = audioCtx.createBufferSource();
                const noiseFilter = audioCtx.createBiquadFilter();
                const noiseGain = audioCtx.createGain();

                noise.buffer = buffer;
                noiseFilter.type = 'lowpass';
                noiseFilter.frequency.setValueAtTime(2000, now);
                noiseFilter.frequency.exponentialRampToValueAtTime(100, now + duration);
                noiseFilter.Q.value = 1;

                noise.connect(noiseFilter);
                noiseFilter.connect(noiseGain);
                noiseGain.connect(masterGain);

                noiseGain.gain.setValueAtTime(0.35 * intensity, now);
                noiseGain.gain.exponentialRampToValueAtTime(0.001, now + duration);

                noise.start(now);
                noise.stop(now + duration);

                // Layer 4: High freq crack - ti·∫øng "t√°ch"
                setTimeout(() => {
                    for (let i = 0; i < 3; i++) {
                        setTimeout(() => {
                            const crack = audioCtx.createOscillator();
                            const crackGain = audioCtx.createGain();
                            crack.connect(crackGain);
                            crackGain.connect(masterGain);
                            crack.type = 'square';
                            crack.frequency.value = 3000 - (i * 500);
                            crackGain.gain.setValueAtTime(0.12 * intensity, audioCtx.currentTime);
                            crackGain.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 0.08);
                            crack.start();
                            crack.stop(audioCtx.currentTime + 0.08);
                        }, i * 30);
                    }
                }, 25);
            }

            // Ti·∫øng xoay - m∆∞·ª£t m√†
            function playRotateSound() {
                const now = audioCtx.currentTime;
                const osc = audioCtx.createOscillator();
                const gain = audioCtx.createGain();
                osc.connect(gain);
                gain.connect(masterGain);
                osc.type = 'sine';
                osc.frequency.setValueAtTime(600, now);
                osc.frequency.linearRampToValueAtTime(900, now + 0.05);
                gain.gain.setValueAtTime(0.15, now);
                gain.gain.exponentialRampToValueAtTime(0.001, now + 0.08);
                osc.start(now);
                osc.stop(now + 0.08);
            }

            // Ti·∫øng di chuy·ªÉn - nh·∫π nh√†ng
            function playMoveSound() {
                const now = audioCtx.currentTime;
                const osc = audioCtx.createOscillator();
                const gain = audioCtx.createGain();
                osc.connect(gain);
                gain.connect(masterGain);
                osc.type = 'sine';
                osc.frequency.value = 500;
                gain.gain.setValueAtTime(0.08, now);
                gain.gain.exponentialRampToValueAtTime(0.001, now + 0.04);
                osc.start(now);
                osc.stop(now + 0.04);
            }

            // Ti·∫øng game over - bi th·∫£m
            function playGameOverSound() {
                const now = audioCtx.currentTime;
                const notes = [440, 392, 349, 311, 277];

                notes.forEach((freq, i) => {
                    setTimeout(() => {
                        const osc = audioCtx.createOscillator();
                        const gain = audioCtx.createGain();
                        osc.connect(gain);
                        gain.connect(masterGain);
                        osc.type = 'sawtooth';
                        osc.frequency.value = freq;
                        gain.gain.setValueAtTime(0.2, audioCtx.currentTime);
                        gain.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 0.3);
                        osc.start();
                        osc.stop(audioCtx.currentTime + 0.3);
                    }, i * 120);
                });

                // Th√™m reverb effect v·ªõi delay
                setTimeout(() => {
                    const rumble = audioCtx.createOscillator();
                    const rumbleGain = audioCtx.createGain();
                    rumble.connect(rumbleGain);
                    rumbleGain.connect(masterGain);
                    rumble.type = 'sine';
                    rumble.frequency.value = 80;
                    rumbleGain.gain.setValueAtTime(0.3, audioCtx.currentTime);
                    rumbleGain.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 1);
                    rumble.start();
                    rumble.stop(audioCtx.currentTime + 1);
                }, 200);
            }

            // Ti·∫øng level up - ph·∫•n kh√≠ch
            function playLevelUpSound() {
                const now = audioCtx.currentTime;
                const melody = [523, 659, 784, 1047];

                melody.forEach((freq, i) => {
                    setTimeout(() => {
                        const osc = audioCtx.createOscillator();
                        const gain = audioCtx.createGain();
                        osc.connect(gain);
                        gain.connect(masterGain);
                        osc.type = 'square';
                        osc.frequency.value = freq;
                        gain.gain.setValueAtTime(0.15, audioCtx.currentTime);
                        gain.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 0.15);
                        osc.start();
                        osc.stop(audioCtx.currentTime + 0.15);
                    }, i * 80);
                });
            }

            // Tia l·ª≠a b·∫Øn ra t·ª´ v·ªã tr√≠ va ch·∫°m
            function createSparks(x, y, count = 25) {
                const rect = canvas.getBoundingClientRect();
                const centerX = rect.left + x;
                const centerY = rect.top + y;

                for (let i = 0; i < count; i++) {
                    const spark = document.createElement('div');
                    spark.className = 'spark';

                    const angle = (Math.random() * 120 - 60) + 90; // B·∫Øn l√™n tr√™n ch·ªß y·∫øu
                    const velocity = 50 + Math.random() * 100;
                    const tx = Math.cos(angle * Math.PI / 180) * velocity;
                    const ty = Math.sin(angle * Math.PI / 180) * velocity + Math.random() * 50; // Gravity
                    const rotate = Math.random() * 360;

                    spark.style.cssText = `
                        left: ${centerX}px;
                        top: ${centerY}px;
                        --tx: ${tx}px;
                        --ty: ${ty}px;
                        --rotate: ${rotate}deg;
                        animation: sparkFly ${0.3 + Math.random() * 0.3}s ease-out forwards;
                    `;

                    document.body.appendChild(spark);
                    setTimeout(() => spark.remove(), 600);
                }
            }

            // Rung m√†n h√¨nh khi va ch·∫°m
            function screenShake(intensity = 1) {
                board.classList.remove('shake');
                void board.offsetWidth; // Force reflow
                board.classList.add('shake');
                setTimeout(() => board.classList.remove('shake'), 300);

                // Vibration API n·∫øu c√≥
                if (navigator.vibrate) {
                    navigator.vibrate(intensity * 50);
                }
            }

            // V·ª• n·ªï v·ªõi shockwave khi x√≥a h√†ng
            function createExplosion(x, y, color, intensity = 1) {
                const rect = canvas.getBoundingClientRect();
                const centerX = rect.left + x;
                const centerY = rect.top + y;

                // Shockwave
                const shockwave = document.createElement('div');
                shockwave.className = 'shockwave';
                shockwave.style.cssText = `
                    left: ${centerX}px;
                    top: ${centerY}px;
                    transform: translate(-50%, -50%);
                    animation: shockwave ${0.6 * intensity}s ease-out forwards;
                `;
                document.body.appendChild(shockwave);
                setTimeout(() => shockwave.remove(), 600 * intensity);

                // Particles
                const particleCount = 40 * intensity;
                const colors = ['#ff6600', '#ffff00', '#ff0000', '#ff9900'];

                for (let i = 0; i < particleCount; i++) {
                    const particle = document.createElement('div');
                    particle.className = 'explosion-particle';

                    const angle = (Math.random() * 360);
                    const velocity = 80 + Math.random() * 120;
                    const tx = Math.cos(angle * Math.PI / 180) * velocity;
                    const ty = Math.sin(angle * Math.PI / 180) * velocity;
                    const particleColor = colors[Math.floor(Math.random() * colors.length)];

                    particle.style.cssText = `
                        left: ${centerX}px;
                        top: ${centerY}px;
                        background: ${particleColor};
                        color: ${particleColor};
                        --tx: ${tx}px;
                        --ty: ${ty}px;
                        animation: explode ${0.5 + Math.random() * 0.5}s ease-out forwards;
                    `;

                    document.body.appendChild(particle);
                    setTimeout(() => particle.remove(), 1000);
                }
            }

            // Tetromino Shapes
            const SHAPES = {
                I: { color: '#00f0f0', blocks: [[0, 0, 0, 0], [1, 1, 1, 1], [0, 0, 0, 0], [0, 0, 0, 0]] },
                J: { color: '#0000f0', blocks: [[1, 0, 0], [1, 1, 1], [0, 0, 0]] },
                L: { color: '#f0a000', blocks: [[0, 0, 1], [1, 1, 1], [0, 0, 0]] },
                O: { color: '#f0f000', blocks: [[1, 1], [1, 1]] },
                S: { color: '#00f000', blocks: [[0, 1, 1], [1, 1, 0], [0, 0, 0]] },
                T: { color: '#a000f0', blocks: [[0, 1, 0], [1, 1, 1], [0, 0, 0]] },
                Z: { color: '#f00000', blocks: [[1, 1, 0], [0, 1, 1], [0, 0, 0]] }
            };

            // Game State
            let grid, current, nextQueue, holdPiece = null, holdUsed = false;
            let score = 0, lines = 0, level = 1;
            let dropCounter = 0, dropInterval = 800, lastTime = 0;
            let running = false, paused = false, gameOver = false;

            function createGrid() {
                return Array.from({ length: ROWS }, () => Array(COLS).fill(0));
            }

            function drawCell(x, y, color, glow = false) {
                const px = x * cell;
                const py = y * cell;

                const gradient = ctx.createLinearGradient(px, py, px + cell, py + cell);
                gradient.addColorStop(0, color);
                gradient.addColorStop(1, adjustBrightness(color, -30));
                ctx.fillStyle = gradient;
                ctx.fillRect(px + 1, py + 1, cell - 2, cell - 2);

                if (glow) {
                    ctx.shadowColor = color;
                    ctx.shadowBlur = 15;
                    ctx.strokeStyle = adjustBrightness(color, 50);
                    ctx.lineWidth = 2;
                    ctx.strokeRect(px + 2, py + 2, cell - 4, cell - 4);
                    ctx.shadowBlur = 0;
                }

                ctx.fillStyle = 'rgba(255,255,255,0.3)';
                ctx.fillRect(px + 2, py + 2, cell - 8, 3);
            }

            function adjustBrightness(color, amount) {
                const num = parseInt(color.replace('#', ''), 16);
                const r = Math.max(0, Math.min(255, (num >> 16) + amount));
                const g = Math.max(0, Math.min(255, ((num >> 8) & 0x00FF) + amount));
                const b = Math.max(0, Math.min(255, (num & 0x0000FF) + amount));
                return `#${((r << 16) | (g << 8) | b).toString(16).padStart(6, '0')}`;
            }

            function drawGrid() {
                ctx.fillStyle = '#050212';
                ctx.fillRect(0, 0, canvas.width, canvas.height);

                ctx.strokeStyle = 'rgba(255,45,117,0.1)';
                ctx.lineWidth = 1;
                for (let i = 0; i <= COLS; i++) {
                    ctx.beginPath();
                    ctx.moveTo(i * cell, 0);
                    ctx.lineTo(i * cell, canvas.height);
                    ctx.stroke();
                }
                for (let i = 0; i <= ROWS; i++) {
                    ctx.beginPath();
                    ctx.moveTo(0, i * cell);
                    ctx.lineTo(canvas.width, i * cell);
                    ctx.stroke();
                }

                for (let r = 0; r < ROWS; r++) {
                    for (let c = 0; c < COLS; c++) {
                        if (grid[r][c]) {
                            drawCell(c, r, grid[r][c], true);
                        }
                    }
                }
            }

            function randomPiece() {
                const keys = Object.keys(SHAPES);
                const k = keys[Math.floor(Math.random() * keys.length)];
                const def = SHAPES[k];
                return {
                    type: k,
                    matrix: def.blocks.map(row => row.slice()),
                    color: def.color,
                    x: Math.floor((COLS - def.blocks[0].length) / 2),
                    y: -1
                };
            }

            function rotate(matrix) {
                const N = matrix.length;
                const res = Array.from({ length: N }, () => Array(N).fill(0));
                for (let y = 0; y < N; y++) {
                    for (let x = 0; x < N; x++) {
                        res[x][N - 1 - y] = matrix[y][x];
                    }
                }
                return res;
            }

            function collide(piece, pos) {
                for (let y = 0; y < piece.matrix.length; y++) {
                    for (let x = 0; x < piece.matrix[y].length; x++) {
                        if (piece.matrix[y][x]) {
                            const gx = pos.x + x;
                            const gy = pos.y + y;
                            if (gx < 0 || gx >= COLS || gy >= ROWS) return true;
                            if (gy >= 0 && grid[gy][gx]) return true;
                        }
                    }
                }
                return false;
            }

            function merge(piece) {
                let minY = ROWS;
                const impactPoints = [];

                for (let y = 0; y < piece.matrix.length; y++) {
                    for (let x = 0; x < piece.matrix[y].length; x++) {
                        if (piece.matrix[y][x]) {
                            const gx = piece.x + x;
                            const gy = piece.y + y;
                            if (gy >= 0) {
                                grid[gy][gx] = piece.color;
                                if (gy < minY) minY = gy;

                                // Ki·ªÉm tra va ch·∫°m v·ªõi ƒë√°y ho·∫∑c g·∫°ch kh√°c
                                if (gy === ROWS - 1 || (gy + 1 < ROWS && grid[gy + 1][gx])) {
                                    impactPoints.push({ x: gx, y: gy });
                                }
                            }
                        }
                    }
                }

                // T·∫°o hi·ªáu ·ª©ng tia l·ª≠a t·∫°i c√°c ƒëi·ªÉm va ch·∫°m
                impactPoints.forEach(point => {
                    const px = (point.x + 0.5) * cell;
                    const py = (point.y + 1) * cell;
                    createSparks(px, py, 15);
                });

                if (impactPoints.length > 0) {
                    playGrindSound();
                    screenShake(0.5);
                }
            }

            function sweep() {
                let rowCount = 0;
                const clearedRows = [];

                for (let y = ROWS - 1; y >= 0; y--) {
                    let full = true;
                    for (let x = 0; x < COLS; x++) {
                        if (!grid[y][x]) {
                            full = false;
                            break;
                        }
                    }
                    if (full) {
                        clearedRows.push(y);
                        grid.splice(y, 1);
                        grid.unshift(Array(COLS).fill(0));
                        rowCount++;
                        y++;
                    }
                }

                if (rowCount > 0) {
                    // V·ª• n·ªï BOM t·∫°i c√°c h√†ng b·ªã x√≥a
                    clearedRows.forEach((row, index) => {
                        setTimeout(() => {
                            for (let x = 0; x < COLS; x += 2) {
                                const px = (x + 0.5) * cell;
                                const py = row * cell;
                                createExplosion(px, py, '#ff6600', rowCount * 0.5);
                            }
                        }, index * 50);
                    });

                    // Rung m·∫°nh khi x√≥a h√†ng
                    screenShake(rowCount);

                    // √Çm thanh bom n·ªï
                    playExplosionSound(rowCount);

                    // Scoring
                    const pointsMap = { 1: 40, 2: 100, 3: 300, 4: 1200 };
                    score += (pointsMap[rowCount] || rowCount * 100) * level;
                    lines += rowCount;

                    const newLevel = Math.floor(lines / 10) + 1;
                    if (newLevel !== level) {
                        level = newLevel;
                        dropInterval = Math.max(100, 800 - (level - 1) * 50);
                        playTone(1200, 0.3, 'square', 0.2);
                    }

                    updateUI();
                }
            }

            function spawn() {
                current = nextQueue.shift();
                nextQueue.push(randomPiece());
                holdUsed = false;

                if (collide(current, { x: current.x, y: current.y })) {
                    running = false;
                    gameOver = true;
                    playGameOverSound();
                    setTimeout(() => {
                        alert(`üéÆ GAME OVER!\n\nüíØ Score: ${score}\nüìä Lines: ${lines}\n‚≠ê Level: ${level}`);
                    }, 800);
                }
                renderHoldNext();
            }

            function hardDrop() {
                let dropDist = 0;
                while (!collide(current, { x: current.x, y: current.y + 1 })) {
                    current.y++;
                    dropDist++;
                }
                score += dropDist * 2;

                // T·∫°o hi·ªáu ·ª©ng r∆°i m·∫°nh
                merge(current);
                sweep();
                spawn();
                updateUI();
            }

            function softDrop() {
                current.y++;
                if (collide(current, { x: current.x, y: current.y })) {
                    current.y--;
                    merge(current);
                    sweep();
                    spawn();
                } else {
                    score += 1;
                    updateUI();
                }
            }

            function move(dir) {
                current.x += dir;
                if (collide(current, { x: current.x, y: current.y })) {
                    current.x -= dir;
                } else {
                    playMoveSound();
                }
            }

            function rotateCurrent() {
                const prev = current.matrix;
                current.matrix = rotate(prev);
                const oldX = current.x;

                const kicks = [0, -1, 1, -2, 2];
                let ok = false;
                for (let k of kicks) {
                    current.x = oldX + k;
                    if (!collide(current, { x: current.x, y: current.y })) {
                        ok = true;
                        break;
                    }
                }

                if (!ok) {
                    current.matrix = prev;
                    current.x = oldX;
                } else {
                    playRotateSound();
                }
            }

            function hold() {
                if (holdUsed) return;
                if (!holdPiece) {
                    holdPiece = { type: current.type, matrix: current.matrix, color: current.color };
                    spawn();
                } else {
                    const tmp = { ...current };
                    current = { ...holdPiece, x: Math.floor((COLS - holdPiece.matrix[0].length) / 2), y: -1 };
                    holdPiece = tmp;
                }
                holdUsed = true;
                renderHoldNext();
                playTone(600, 0.05, 'sine', 0.08);
            }

            function drawCurrent() {
                // Draw ghost piece
                const ghost = { ...current };
                while (!collide(ghost, { x: ghost.x, y: ghost.y + 1 })) {
                    ghost.y++;
                }
                for (let y = 0; y < ghost.matrix.length; y++) {
                    for (let x = 0; x < ghost.matrix[y].length; x++) {
                        if (ghost.matrix[y][x]) {
                            const gx = ghost.x + x;
                            const gy = ghost.y + y;
                            if (gy >= 0) {
                                ctx.fillStyle = 'rgba(255,255,255,0.1)';
                                ctx.fillRect(gx * cell + 2, gy * cell + 2, cell - 4, cell - 4);
                            }
                        }
                    }
                }

                // Draw current piece with glow
                for (let y = 0; y < current.matrix.length; y++) {
                    for (let x = 0; x < current.matrix[y].length; x++) {
                        if (current.matrix[y][x]) {
                            const gx = current.x + x;
                            const gy = current.y + y;
                            if (gy >= 0) {
                                drawCell(gx, gy, current.color, true);
                            }
                        }
                    }
                }
            }

            function renderHoldNext() {
                nextEl.innerHTML = '';
                holdEl.innerHTML = '';
                if (nextQueue[0]) drawMini(nextQueue[0], nextEl);
                if (holdPiece) drawMini(holdPiece, holdEl);
            }

            function drawMini(piece, container) {
                const miniCanvas = document.createElement('canvas');
                const mat = piece.matrix;
                const s = 20;
                miniCanvas.width = mat[0].length * s;
                miniCanvas.height = mat.length * s;
                const mctx = miniCanvas.getContext('2d');

                for (let y = 0; y < mat.length; y++) {
                    for (let x = 0; x < mat[y].length; x++) {
                        if (mat[y][x]) {
                            mctx.fillStyle = piece.color;
                            mctx.fillRect(x * s + 2, y * s + 2, s - 4, s - 4);
                            mctx.strokeStyle = adjustBrightness(piece.color, 50);
                            mctx.lineWidth = 2;
                            mctx.strokeRect(x * s + 2, y * s + 2, s - 4, s - 4);
                        }
                    }
                }
                container.appendChild(miniCanvas);
            }

            function updateUI() {
                scoreEl.textContent = score.toLocaleString();
                linesEl.textContent = lines;
                levelEl.textContent = level;
            }

            function update(time = 0) {
                if (!running || paused) {
                    lastTime = time;
                    requestAnimationFrame(update);
                    return;
                }

                const delta = time - lastTime;
                lastTime = time;
                dropCounter += delta;

                if (dropCounter > dropInterval) {
                    if (!collide(current, { x: current.x, y: current.y + 1 })) {
                        current.y++;
                    } else {
                        merge(current);
                        sweep();
                        spawn();
                    }
                    dropCounter = 0;
                }

                drawGrid();
                drawCurrent();
                requestAnimationFrame(update);
            }

            // Input handling
            document.addEventListener('keydown', (e) => {
                if (!running || paused) return;

                switch (e.keyCode) {
                    case 37: move(-1); break;
                    case 39: move(1); break;
                    case 38: rotateCurrent(); break;
                    case 40: softDrop(); break;
                    case 32: e.preventDefault(); hardDrop(); break;
                    case 67: hold(); break;
                    case 80: togglePause(); break;
                }
            });

            // Buttons
            document.getElementById('btn-start').addEventListener('click', start);
            document.getElementById('btn-pause').addEventListener('click', togglePause);
            document.getElementById('btn-reset').addEventListener('click', () => {
                if (confirm('üîÑ Reset game?')) init();
            });

            function togglePause() {
                if (!running) return;
                paused = !paused;
                document.getElementById('btn-pause').textContent = paused ? '‚ñ∂ RESUME' : '‚è∏ PAUSE';
                if (!paused) lastTime = performance.now();
            }

            function init() {
                grid = createGrid();
                nextQueue = [randomPiece(), randomPiece(), randomPiece()];
                current = randomPiece();
                holdPiece = null;
                holdUsed = false;
                score = 0;
                lines = 0;
                level = 1;
                dropInterval = 800;
                running = false;
                paused = false;
                gameOver = false;
                updateUI();
                renderHoldNext();
                drawGrid();
            }

            function start() {
                if (gameOver) init();
                if (!running) {
                    running = true;
                    lastTime = performance.now();
                    dropCounter = 0;
                    spawn();
                    requestAnimationFrame(update);
                    playTone(1000, 0.1, 'square', 0.15);
                }
            }

            // Initialize
            init();
            document.body.addEventListener('touchstart', () => audioCtx.resume(), { once: true });
        })();
    </script>
</body>

</html>